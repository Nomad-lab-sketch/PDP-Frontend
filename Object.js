/*=============================================
=        Копирование объектов и ссылки        =
=============================================*/

// ─── Ссылки ──────────────────────────────────────────────────────────────────

// Ссылка - это адрес по которому компьютер находит участок памяти в которой хранится объект
let a = {};
let b = a;
// копирование объектной переменной создаёт ещё одну ссылку на тот же объект
// a == b > true т.к a и b ссылаются на один и тот же объект

let c = {};
let d = {};
// c == d > false т.к это 2 независимых объекта


// ─── Клонирование Объектов ───────────────────────────────────────────────────

let user = {
	name: "John",
	age: 30
};

/*----------  for in  ----------*/

let clone = {};

for (let key in user) {
	clone[key] = user[key]
}


/*----------  assign  ----------*/

const permissions = { canView: true };

// копируем все свойства из permissions в user
Object.assign(user, permissions)

// теперь user = { name: "John", canView: true, canEdit: true }
// Если скопированное имя свойства уже существует, оно будет перезаписано
// Мы также можем использовать Object.assign для замены цикла for..in для простого клонирования:

let clone2 = Object.assign({}, user);

/*----------  spread  ----------*/

const cloneSpread = { ...user };


// ─── Вложенное Клонирование ──────────────────────────────────────────────────

let userDeep = {
	name: "John",
	sizes: {
		height: 182,
		width: 50
	}
};

/*----------  structuredClone  ----------*/

// structuredClone поддерживается только современными браузерами 

// const cloneStructuredClone = structuredClone(userDeep);

/*----------  JSON  ----------*/

// При таком подходе теряются все методы у объектов
const cloneJSON = JSON.parse(JSON.stringify(userDeep));

/*----------  Рекурсия  ----------*/

function deepCopy(obj) {
	if (typeof obj !== "object" || obj === null) {
		return obj;
	}

	let copy = Array.isArray(obj) ? [] : {};

	for (let key in obj) {
		copy[key] = deepCopy(obj[key]);
	}

	return copy;
}

let cloneRecursion = deepCopy(userDeep);

/*----------  lodash  ----------*/

// const cloneLodash = cloneDeep(userDeep); 


/*=====  End of Копирование объектов и ссылки  ======*/



/*=============================================
=         Конструктор, оператор "new"         =
=============================================*/

// Такие конструкции нужны для создания однотипных объектов 

// 1) Имя функции конструктора должно начинаться с заглавной буквы 
// 2) Функция конструктор должна выполняться с помощью оператора new  

function UserConstructor(name) {
	this.name = name;
	this.isSuperAdmin = false;
}

const programmer = new UserConstructor('John');

// Создаётся новый пустой объект, и он присваивается this.
// Выполняется тело функции. Обычно оно модифицирует this, добавляя туда новые свойства.
// Возвращается значение this.

// В качестве конструктора может использоваться любая функция (кроме стрелочных т.к у них нет this)


// ─── Проверка На Вызов В Режиме Конструктора: New.target ─────────────────────

function UserCheckNew(name) {
	if (new.target) {
		// Если функция конструктор была вызвана с помощью new то new.target будет равен самой функции, а иначе undefined 
	}

	if (!new.target) {
		// Если функция конструктор была вызвана без new то мы можем переадресовать вызов с использованием new
		return new UserCheckNew(name)
	}

	this.sayHi = function () {
		return `Hi ${this.name}`
	}

	this.name = name;
}

/*=====  End of Конструктор, оператор "new"  ======*/



/*=============================================
=            Контекст выполнения              =
=============================================*/

const hello = 'Hello';

const executionContext = function () { // контекст выполнения функции
	const name = 'John Smith';

	const getName = function () { // контекст выполнения функции
		return name;
	}

	const sayHello = function () { // контекст выполнения функции
		console.log(hello + ', ' + getName());
	}

	sayHello();
}

// Когда интерпретатор JavaScript выполняет код, по умолчанию контекстом выполнения является глобальный контекст. 
// Каждый вызов функции приводит к созданию нового контекста выполнения.

// По сути контекст выполнения представляет собой некую обертку для выполняемого кода, содержащую определенные вспомогательные компоненты для отслеживания состояния программы.

/*=====  End of Контекст выполнения  ======*/







