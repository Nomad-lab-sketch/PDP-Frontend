// Генераторы - функции которые умеют останавливать свое исполнение и возвращать промежуточный
// результат. Очень полезно когда нам необходимо на каком то этапе выполнения функции с промежуточными 
// результатами что то сделать 

function* generateSequence() {
	yield 1;
	yield 2;
	return 3;
}

// Ключевое слово yield используется для приостановки выполнения функции и возврата значения. 
// Когда генератор вызывается, он возвращает объект-итератор, который может быть использован 
// для последовательного получения значений из генератора:

const generator = myGenerator();
console.log(generator.next()); // { value: 1, done: false }
console.log(generator.next()); // { value: 2, done: false }
console.log(generator.next()); // { value: 3, done: false }
console.log(generator.next()); // { value: undefined, done: true }

// Генераторы могут использоваться для управления асинхронным кодом, например, 
// для выполнения нескольких асинхронных операций последовательно или параллельно. 
// Они могут также использоваться для создания итераторов для коллекций данных.


// Т.к генератор возвращает итератор его можно использовать в цикле 

for (let value of generator) {
	alert(value); // 1, затем 2
}

// Один генератор может включать в себя другие. Это называется композицией.


// Генераторы создаются при помощи функций-генераторов function*(…) {…}.
// Внутри генераторов и только внутри них разрешён оператор yield. Это иногда создаёт 
// неудобства, поскольку в колбэках .map/.forEach сделать yield нельзя. 
// Впрочем, можно сделать yield массива (при использовании co).
// Внешний код и генератор обмениваются промежуточными результатами посредством вызовов next/yield.
// Генераторы позволяют писать плоский асинхронный код, при помощи библиотеки co.