let arr = ["cat", 1, {}, 2, 3, "leroy jenkin"];

/*----------  Добавление/Удаление элементов  ----------*/

// push(...items) – добавляет элементы в конец,
// pop() – извлекает элемент с конца,
// shift() – извлекает элемент с начала,
// unshift(...items) – добавляет элементы в начало.

// Т.к массивы это объекты то можно удалять элементы таким образом 
delete arr[1];


// ─── Splice ──────────────────────────────────────────────────────────────────

// splice(pos, deleteCount, ...items) – начиная с индекса pos удаляет deleteCount элементов и вставляет items.
arr.splice(1, 1); // начиная с индекса 1, удалить 1 элемент

// ─── Slice ───────────────────────────────────────────────────────────────────

// Возвращает новый массив, в который копирует все элементы с индекса start до end (не включая end). 
// start и end могут быть отрицательными, в этом случае отсчёт позиции будет вестись с конца массива.

// slice(start, end) – создаёт новый массив, копируя в него элементы с индекса start до end (не включая end).
arr.slice(1, 3); // e,s (копирует с 1 до 3)

// ─── Concat ──────────────────────────────────────────────────────────────────

// concat(...items) – возвращает новый массив: копирует все члены текущего массива и добавляет к нему items. Если какой-то из items является массивом, тогда берутся его элементы.
// Для поиска среди элементов:
arr.concat([3, 4], [5, 6]);



/*----------  Поиск в массиве  ----------*/

// ─── Indexof/Lastindexof и Includes ────────────────────────────────────────────

// indexOf/lastIndexOf(item, pos) – ищет item, начиная с позиции pos, и возвращает его индекс или -1, если ничего не найдено.
arr.indexOf(0); // -1
arr.indexOf("cat"); // 0
arr.indexOf(null); // -1

arr.lastIndexOf('Apple'); // тоже самое что и indexOf только ищет справа на лево.

// includes(value) – возвращает true, если в массиве имеется элемент value, в противном случае false.
arr.includes(1); // true


// ─── Find И Findindex/Findlastindex ──────────────────────────────────────────

// find – фильтрует элементы через функцию и отдаёт первое значения, при прохождении которых через функцию возвращается true.
let resultFind = arr.find(function (item, index, array) {
	// если true - возвращается текущий элемент и перебор прерывается
	// если все итерации оказались ложными, возвращается undefined
});

// findIndex похож на find, но возвращает индекс вместо значения.
arr.findIndex(user => user.name == 'leroy jenkin');

// Тоже самое что и findIndex только ищет справа на лево
arr.findLastIndex(user => user.name == 'leroy jenkin');

// ─── Filter ──────────────────────────────────────────────────────────────────

let resultsFilter = arr.filter(function (item, index, array) {
	// если `true` -- элемент добавляется к results и перебор продолжается
	// возвращается пустой массив в случае, если ничего не найдено
});


/*----------  Перебор  ----------*/

// ─── Foreach ─────────────────────────────────────────────────────────────────

// forEach(func) – вызывает func для каждого элемента. Ничего не возвращает.
// Для преобразования массива:
arr.forEach(function (item, index, array) {
	// ... делать что-то с item
});


/*----------  Преобразование массива  ----------*/

// ─── Map ─────────────────────────────────────────────────────────────────────

// map(func) – создаёт новый массив из результатов вызова func для каждого элемента.
let resultMap = arr.map(function (item, index, array) {
	// возвращается новое значение вместо элемента
});

// ─── Sort ────────────────────────────────────────────────────────────────────

// Сортирует исходный массив
// По умолчанию метод сортирует массив как строки 

// sort(func) – сортирует массив «на месте», а потом возвращает его.
arr.sort((a, b) => a - b);

// ─── Reverse ─────────────────────────────────────────────────────────────────

// reverse() – «на месте» меняет порядок следования элементов на противоположный и возвращает изменённый массив.
arr.reverse();

// ─── Split/join ───────────────────────────────────────────────────────────────

// split/join – преобразует строку в массив и обратно.

//разбивает строку на массив по заданному разделителю
let arrSplit = 'ехал грека через реку'.split(', ');

//создаёт строку из элементов arr
let strJoin = arrSplit.join(';');

// ─── reduce/reduceRight ───────────────────────────────────────────────────────

// reduce/reduceRight(func, initial) – вычисляет одно значение на основе всего массива, 
// вызывая func для каждого элемента и передавая промежуточный результат между вызовами.
// Дополнительно:
let value = arr.reduce((accumulator, item, index, array) => {
	// ...
}, [initial]);

//   accumulator – результат предыдущего вызова этой функции, равен initial при первом вызове (если передан initial),
//   item – очередной элемент массива,
//   index – его позиция,
//   array – сам массив.

// reduceRight тоже самое что и reduce только выполняется справа на лево

// ─── Isarray ─────────────────────────────────────────────────────────────────

// Array.isArray(arr) проверяет, является ли arr массивом.
Array.isArray(arr) // true


/*----------  P.S  ----------*/

// Большинство методов поддерживают «thisArg»

let army = {
	minAge: 18,
	maxAge: 27,
	canJoin(user) {
		return user.age >= this.minAge && user.age < this.maxAge;
	}
};

let users = [
	{ age: 16 },
	{ age: 20 },
	{ age: 23 },
	{ age: 30 }
];

let arrThisArg = users.filter(army.canJoin, army);


// ВНИМАНИЕ методы push, pop, shift, unshift, sort, reverse и splice изменяют исходный массив.

// Весь список методов массивов https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array