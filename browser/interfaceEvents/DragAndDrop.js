// Базовый алгоритм Drag’n’Drop выглядит так:

// При mousedown – готовим элемент к перемещению, если необходимо(например, создаём его копию).
// Затем при mousemove передвигаем элемент на новые координаты путём смены left / top и position: absolute.
// При mouseup – остановить перенос элемента и произвести все действия, связанные с окончанием Drag’n’Drop.


ball.onmousedown = function (event) { // (1) отследить нажатие

	// (2) подготовить к перемещению:
	// разместить поверх остального содержимого и в абсолютных координатах
	ball.style.position = 'absolute';
	ball.style.zIndex = 1000;
	// переместим в body, чтобы мяч был точно не внутри position:relative
	document.body.append(ball);
	// и установим абсолютно спозиционированный мяч под курсор

	moveAt(event.pageX, event.pageY);

	// передвинуть мяч под координаты курсора
	// и сдвинуть на половину ширины/высоты для центрирования
	function moveAt(pageX, pageY) {
		ball.style.left = pageX - ball.offsetWidth / 2 + 'px';
		ball.style.top = pageY - ball.offsetHeight / 2 + 'px';
	}

	function onMouseMove(event) {
		moveAt(event.pageX, event.pageY);
	}

	// (3) перемещать по экрану
	document.addEventListener('mousemove', onMouseMove);

	// (4) положить мяч, удалить более ненужные обработчики событий
	ball.onmouseup = function () {
		document.removeEventListener('mousemove', onMouseMove);
		ball.onmouseup = null;
	};

};

// Если запустить этот код, то мы заметим нечто странное. 
// При начале переноса мяч «раздваивается» и переносится не сам мяч, а его «клон».

// Всё потому, что браузер имеет свой собственный Drag’n’Drop, 
// который автоматически запускается и вступает в конфликт с нашим. 

// Его нужно отключить:

ball.ondragstart = function () {
	return false;
};

// Ещё одна деталь – событие mousemove отслеживается на document, а не на ball
// Событие mousemove возникает хоть и часто, но не для каждого пикселя
// Поэтому из-за быстрого движения указатель может спрыгнуть с мяча и оказаться где-нибудь 
// в середине документа (или даже за пределами окна).

// Вот почему мы должны отслеживать mousemove на всём document, чтобы поймать его.

// ─── Правильное Позиционирование ─────────────────────────────────────────────

// Мы, для начала переноса, можем нажать мышью на любом месте мяча. Если мячик «взят» за самый 
// край – то в начале переноса он резко «прыгает», центрируясь под указателем мыши.

// Было бы лучше, если бы изначальный сдвиг курсора относительно элемента сохранялся.

// Когда человек нажимает на мячик (mousedown) – запомним расстояние от курсора до левого верхнего угла шара 
// в переменных shiftX/shiftY. Далее будем удерживать это расстояние при перетаскивании.

// onmousedown
let shiftX = event.clientX - ball.getBoundingClientRect().left;
let shiftY = event.clientY - ball.getBoundingClientRect().top;

// Далее при переносе мяча мы позиционируем его с тем же сдвигом относительно указателя мыши, вот так:

// onmousemove
// ball has position:absoute
ball.style.left = event.pageX - shiftX + 'px';
ball.style.top = event.pageY - shiftY + 'px';

// ─── Цели Переноса Droppable ─────────────────────────────────────────────────

// В примерах выше мы могли разместить перетаскиваемый элемент в любом месте экрана. В реальности за частую
// необходимо перенести один элемент на место другого или один в другой. Например файл в папку.

// Возникает вопрос каким образом узнать на какой элемент у нас был перенес объект. Повесить обработчик события 
// не получиться т.к он будет срабатывать на этом самом объекте т.к он у нас находиться выше всех 

// Существует метод document.elementFromPoint(clientX, clientY). 
// Он возвращает наиболее глубоко вложенный элемент по заданным координатам окна

// Мы можем использовать его, чтобы из любого обработчика событий мыши выяснить, 
// над какой мы потенциальной целью переноса, вот так:

// внутри обработчика события мыши
ball.hidden = true; // (*) прячем переносимый элемент

let elemBelow = document.elementFromPoint(event.clientX, event.clientY);
// elemBelow - элемент под мячом (возможная цель переноса)

ball.hidden = false;